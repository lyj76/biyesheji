# CLUT-VDFE (基于聚类查找表的 Volterra DFE) 原理全解

本文档为你揭示《Low-complexity cluster-assisting look-up-table-based Volterra decision-feedback equalizer》这篇论文背后的直觉与智慧。

---

## 核心解惑：为什么连 `0.5 * x` 这种乘法都不用做？

这是初学者最容易卡住的地方。请务必先看懂这一节。

### 1. 你的疑问
假设我们训练出来的系数是 $h = 0.5$。
现在的输入信号是 $x = -3$。
你可能会想：“查表只是查到了 $0.5$，那最后不还得算 $0.5 \times -3 = -1.5$ 吗？这不还是乘法吗？”

### 2. 真正的查表逻辑 (Pre-calculation)
**不是存系数，而是存“乘积的结果”！**

因为 PAM4 信号的输入 $x$ 只有 4 种可能性：$\{-3, -1, +1, +3\}$。
既然系数 $h=0.5$ 是固定的（离线训练好的），那我们为什么不把这 4 种可能的结果**提前算好**呢？

**建表阶段（离线准备）**：
我们给系数 $h=0.5$ 造一个小表：
*   地址 00 (对应 x=-3): 存入 **-1.5**  $(0.5 \times -3)$
*   地址 01 (对应 x=-1): 存入 **-0.5**  $(0.5 \times -1)$
*   地址 10 (对应 x=+1): 存入 **+0.5**  $(0.5 \times +1)$
*   地址 11 (对应 x=+3): 存入 **+1.5**  $(0.5 \times +3)$

**工作阶段（在线运行）**：
*   信号 $x=-3$ 来了。
*   我们把它看作**地址索引** (Index)，映射为 `00`。
*   直接去读内存地址 `00` 的数据。
*   读出来 **-1.5**。

**看到了吗？在整个在线工作过程中，没有任何乘法发生。只有“读取内存”这一动作。**

---

## 深度对比：传统算法 vs 查表算法 (数据流视角)

为了回答您关于“传统算法”和“量化”的疑问，我们来一场直观的 PK。

假设场景：
*   输入信号 $x = -3$ (PAM4 的一种状态)。
*   训练好的系数 $h = 0.51234$ (高精度小数)。

### 1. 传统算法 (Real-time Calculation)
这是 `DP_VFFE_VDFE.m` 里的做法，也是大多数 DSP 的做法。

*   **输入**: $x = -3$ (离散整数)
*   **系数**: $h = 0.51234$ (高精度浮点)
*   **动作**: **调用乘法器 (Multiplier)**。
    $$ -3 \times 0.51234 = -1.53702 $$
*   **输出**: $-1.53702$ (高精度浮点)
*   **代价**: 消耗巨大的动态功耗，占用乘法器资源。

### 2. 查表算法 (LUT Approach)
这是本篇论文的做法。

*   **预备**: 在开机前，我们已经算好了：
    *   如果来 -3，结果是 $-1.53702$
    *   如果来 -1，结果是 $-0.51234$
    *   ... 并把它们存进内存。
*   **输入**: $x = -3$
*   **动作**: **调用内存读取 (Memory Read)**。
    *   将 -3 映射为地址 `00`。
    *   读取地址 `00` 的内容。
*   **输出**: $-1.53702$ (高精度浮点)
*   **代价**: 消耗极小的静态功耗，占用内存资源。

### 3. 关键区别总结
您问：“是不是其他算法没有做量化？”

其实真相是：
1.  **输入端**：在 DFE 反馈回路里，输入**永远是有限的**（因为是判决后的符号，只有 -3, -1, 1, 3 这几种）。所有算法在这里都是“量化”的。
2.  **输出端**：无论是传统算出来的，还是查表查出来的，**结果都是高精度的**（没有被量化）。
    *   查表法存的数，可以是 `float` 甚至 `double` 精度。
    *   **查表法并没有损失精度，它只是把“算的过程”省略了，直接给出了“高精度的结果”。**

---

## 第一部分：论文的核心痛点

高速芯片里，做乘法太贵（耗电、占面积），读内存（查表）很便宜。
Volterra 均衡器因为有 $x^2, x^3$ 这种项，乘法量巨大。
我们的目标是：**消灭所有在线乘法**。

---

## 第二部分：CLUT-VDFE 算法原理 (三步走)

### Step 1: 离线训练 (RLS)
先算出几百个系数。
比如：`h1=0.51, h2=0.49, h3=0.1, h4=0.11, h5=0.5`

### Step 2: 聚类压缩 (K-means)
把系数归类，找出“代表”。
*   `0.51, 0.49, 0.5` $\rightarrow$ 归为 **Cluster A (中心值 0.5)**
*   `0.1, 0.11` $\rightarrow$ 归为 **Cluster B (中心值 0.1)**

这意味着，原本要造 5 张表，现在只要造 2 张表（表A 和 表B）。

### Step 3: 预计算建表 (Building LUTs)
**这是关键！** 我们为每个 Cluster 中心值，生成一张**结果表**。

**表 A (代表系数 0.5):**
| 输入 x | 查表索引 | **存的内容 (Result)** |
| :--- | :--- | :--- |
| -3 | 0 | **-1.5** |
| -1 | 1 | **-0.5** |
| +1 | 2 | **+0.5** |
| +3 | 3 | **+1.5** |

**表 B (代表系数 0.1):**
| 输入 x | 查表索引 | **存的内容 (Result)** |
| :--- | :--- | :--- |
| -3 | 0 | **-0.3** |
| -1 | 1 | **-0.1** |
| +1 | 2 | **+0.1** |
| +3 | 3 | **+0.3** |

### Step 4: 在线查表 (Look-Up)
假设现在的信号流是：$x(n)=-3$ (对应 h1)，$x(n-1)=+1$ (对应 h4)。

1.  **处理 h1**: 
    *   h1 属于 Cluster A。
    *   输入是 -3。
    *   去 **表A** 查第 0 行 $\rightarrow$ 得到 **-1.5**。
2.  **处理 h4**: 
    *   h4 属于 Cluster B。
    *   输入是 +1。
    *   去 **表B** 查第 2 行 $\rightarrow$ 得到 **+0.1**。
3.  **累加**: 
    *   输出 = $(-1.5) + (+0.1) = -1.4$。

**全程无乘法！**

---

## 第三部分：数学公式修正

之前那个公式确实写得太抽象，这里给出**正确的工程实现公式**。

### 3.1 线性查表 (L-CLUT)

假设我们有 $L$ 个抽头，每个抽头 $j$ 属于某个簇 $K_j$。

$$ y_{lin}(n) = \sum_{j=1}^{L} \underbrace{\text{LUT}_{K_j} [ \text{Map}(x(n-j)) ]}_{\text{直接读出的数值}} $$

*   $j$: 第几个抽头 (Tap Index)。
*   $K_j$: 这个抽头对应的系数属于第几类 (Cluster ID)。这是离线定好的。
*   $x(n-j)$: 输入信号，作为**地址**。
*   $\text{LUT}_{K_j}$: 第 $K_j$ 号查找表。

### 3.2 非线性查表 (NL-CLUT)

非线性项是两两相乘，比如 $x_1 \cdot x_2$。
*   $x$ 有 4 种取值。
*   $x_1 \cdot x_2$ 的组合结果有 $4 \times 4 = 16$ 种（考虑到对称性和交换律，独立结果更少）。

**逻辑**：
1.  系数 $h_{vol}$ 依然聚类，比如聚成 8 类。
2.  每张表存的是：**系数中心值 $\times$ (两个符号的所有可能积)**。
3.  输入 $(x_1, x_2)$ 来了 $\rightarrow$ 算出它们的积索引 $\rightarrow$ 查表。

---

## 第四部分：为什么要这样折腾？

你可能会问：“为了省一个乘法，造这么多表，值得吗？”

**非常值得！**
1.  **面积对比**：在 7nm 工艺下，一个 16-bit 乘法器的面积，可能是一个小内存块 (Register File) 的几倍甚至十几倍。
2.  **功耗对比**：乘法器翻转时的动态功耗很高。而读小表的功耗极低。
3.  **聚类的魔力**：如果不聚类，你有 100 个抽头就要造 100 张表，那内存就太大了。聚类后，只造 8 张表，大家**共用**这 8 张表，只是查的时候去不同的表里查。这就完美平衡了**计算**与**存储**。

---

## 总结

**CLUT-VDFE 的本质**：
并不是“查出系数再乘”，而是**“把所有可能的乘积结果提前算好，存进表里，用的时候直接读结果”**。

这就是**以存储换计算 (Space for Time)** 的极致体现。