# Volterra FFE + Volterra DFE (全非线性判决反馈均衡器) 原理详解

本文档详细解析了 `DP_VFFE2pscenter_VDFE.m` 代码背后的算法原理。
这是均衡器家族中的 **“终极 BOSS”**，它集结了前面所有算法的特性，试图解决一切已知的信号失真问题。

---

## 1. 为什么要做到这么极致？(Motivation)

我们之前的算法解决了部分问题，但还不够：
1.  **线性 FFE**: 只能解线性干扰，怕噪声。
2.  **线性 DFE**: 能解深衰落，但假设干扰是线性的。
3.  **VNLE (Volterra FFE)**: 能解光纤/器件的非线性，但没有反馈，无法处理严重的频率零点。

**现实中的恶魔是叠加的：**
*   光信号经过了非线性器件（LED/PD/放大器） -> **非线性失真**。
*   光纤传输长距离 -> **色散（记忆效应）**。
*   高速传输带宽受限 -> **严重的 ISI（码间干扰）**。
*   前一个符号不仅以“线性”方式干扰当前符号，甚至以“非线性”方式干扰！（例如：上一个符号的光太强，改变了折射率，导致当前符号相位偏了）。

**解决方案**：
我们要构建一个模型，既包含 **前馈 (Feedforward)** 处理接收信号，又包含 **反馈 (Feedback)** 处理判决信号，并且这两部分 **全都包含非线性项**。

---

## 2. 数学模型：全非线性架构

系统的输出 $y(n)$ 由四部分组成：

$$ y(n) = \underbrace{\mathbf{h}_{lin}^T \mathbf{x}_{Rx}}_{\text{FFE线性}} + \underbrace{\mathbf{h}_{vol}^T \mathbf{x}_{Rx}^{vol}}_{\text{FFE非线性}} + \underbrace{\mathbf{d}_{lin}^T \mathbf{x}_{Dec}}_{\text{DFE线性}} + \underbrace{\mathbf{d}_{vol}^T \mathbf{x}_{Dec}^{vol}}_{\text{DFE非线性}} $$

### 2.1 所有的参数
*   `N1`: FFE 线性长度
*   `N2`: FFE 非线性长度 (通常较短)
*   `D1`: DFE 线性长度
*   `D2`: DFE 非线性长度 (通常较短)
*   `WL`: FFE 非线性记忆深度 (Window Length)
*   `WD`: DFE 非线性记忆深度 (Window Depth)

### 2.2 矩阵构建 (The Big Matrix)
为了使用 RLS 求解，我们再次使用“堆叠技巧”，把这四部分拼成一个超级长的向量 $\mathbf{u}$：

$$ \mathbf{u} = \begin{bmatrix} \mathbf{x}_{FFE-Lin} \\ \mathbf{x}_{FFE-Vol} \\ \mathbf{x}_{DFE-Lin} \\ \mathbf{x}_{DFE-Vol} \end{bmatrix} $$

系数向量 $\mathbf{w}$ 也相应拼接：
$$ \mathbf{w} = \begin{bmatrix} \mathbf{h}_{lin}; \mathbf{h}_{vol}; \mathbf{d}_{lin}; \mathbf{d}_{vol} \end{bmatrix} $$

求解目标依然是最小化误差：
$$ e(n) = d(n) - \mathbf{w}^T \mathbf{u} $$

---

## 番外深度解析：关于“非线性长度短”的反直觉真相

您在阅读时敏锐地发现了一个矛盾：
**“理论上 Volterra 展开会有 $x_1^2, x_1 x_2, x_2^2 \dots$ 这么多项，长度应该爆炸才对，为什么我在代码里说它‘通常较短’（N2 < N1）？”**

这是一个非常深刻的工程权衡问题。让我们拆解一下。

### 1. 非线性项到底长什么样？(组合爆炸)
假设记忆长度 $L=3$，输入窗是 $[x(n), x(n-1), x(n-2)]$。

*   **线性项 (Linear)**: 只有 3 个。
    $$ h_1 x(n), \quad h_2 x(n-1), \quad h_3 x(n-2) $$

*   **非线性项 (Volterra 2阶)**: 每一项都要和大家两两配对。
    *   **自平方**: $x(n)^2, \quad x(n-1)^2, \quad x(n-2)^2$
    *   **相邻交叉**: $x(n)x(n-1), \quad x(n-1)x(n-2)$
    *   **跨步交叉**: $x(n)x(n-2)$
    *   **总数**: $\approx L^2 / 2$。如果 $L=100$，非线性项就有 5000 个！

### 2. 为什么要限制 N2 (非线性记忆长度)？
正因为组合项的数量是按**平方级 ($O(N^2)$)** 增长的，如果让非线性记忆长度 ($N2$) 和线性记忆长度 ($N1$) 一样长，系统会直接崩溃：

*   **维度灾难**: 如果 $N1=100$，做全展开，$N_{vol} \approx 5000$。RLS 需要求 $5000 \times 5000$ 矩阵的逆，芯片直接烧了。
*   **物理事实**:
    *   **线性干扰 (色散)** 确实能拖很长（光纤传了 100km，色散能拖几百个符号）。所以 $N1$ 必须很长（比如 100）。
    *   **非线性干扰 (克尔效应)** 通常是**短程**的。只有当两个光脉冲在时域上重叠得很紧密，或者刚经过放大器光强最强的那一瞬间，才会产生强烈的非线性相互作用。
    *   **结论**：大部分非线性只发生在最近的几个符号之间（比如 $x(n)$ 和 $x(n-1), x(n-2)$）。

### 3. 代码里的巧妙裁剪 (N2 vs N1)
所以，我们在设计算法时采用了**非对称**策略：

*   **线性部分 ($N1 \approx 100$)**: 负责搞定长距离的色散。
*   **非线性部分 ($N2 \approx 20$)**: 只负责搞定最近邻的非线性畸变。我们认为 20 个符号以外的那个 $x(n-100)$ 对现在的 $x(n)$ 即使有非线性影响，也可以忽略不计。

**这就是为什么“项数逻辑上很多”，但在工程参数设置上，我们必须让 N2 保持很短的原因。**

---

## 3. 代码核心逻辑深度拆解

这个代码之所以看起来复杂，是因为它要同时维护 **两个不同的信号源** (Rx 和 Tx/Decision) 的 **两个不同的非线性展开**。

### 3.1 训练阶段 (Training)
在训练阶段，DFE 部分使用的是 **真实的训练序列 (Tx)**。

1.  **FFE 分支 (Rx)**:
    *   线性项：取窗口 `InputRx(n-N1...n+N1)`。
    *   非线性项：计算 `InputRx(i) * InputRx(j)` (由 WL 控制)。

2.  **DFE 分支 (Tx)**:
    *   线性项：取窗口 `DesiredTx(n-1...n-D1)`。
    *   非线性项：计算 `DesiredTx(i) * DesiredTx(j)` (由 WD 控制)。
    *   **注意**：这里模拟的是“过去的符号”对“当前”的非线性干扰。

### 3.2 应用阶段 (Decision Directed)
这是最危险的阶段。DFE 分支的输入变成了 **Buffer 里的判决结果**。

*   **热启动 (Hot Start)**: 前几百个点依然偷看训练序列，防止 RLS 发散。
*   **Buffer 更新**: 每次判决出一个新符号 `hard_sym`，不仅要推入线性 Buffer，还要推入非线性计算逻辑中。

### 3.3 复杂度爆炸警告
你可以看到代码里有类似 `eye(N1 + ... + D2*WD)` 的矩阵初始化。
这个矩阵的维度 $\mathcal{O}(Dim^2)$ 决定了计算量。
*   如果 N1=50, N2=20, D1=20, D2=10...
*   总维度可能达到 150 甚至更多。
*   RLS 每一轮都要更新一个 $150 \times 150$ 的 P 矩阵。
*   **这是极高复杂度的算法，在实际芯片中必须极其谨慎地裁剪参数（比如限制 N2, D2 很小）。**

---

## 4. 总结

*   **DP_VFFE_VDFE** 是这一系列算法的集大成者。
*   它不假设信道是线性的，也不假设干扰是线性的。
*   它通过**暴力穷举**所有可能的线性与非线性、前馈与反馈的组合项，试图逼近信道的完美逆模型。
*   代价是**计算量巨大**和**收敛所需的训练数据量增加**。
